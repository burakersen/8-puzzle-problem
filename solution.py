# -*- coding: utf-8 -*-
"""HomeworkI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dOq-Hva8RIvksDLZ8TsSw2j79Q41IENN

8-puzzle problem
"""

# Depth first search in search of target - Using Recursion
import numpy as np

def dfs(src,target,limit,visited_states):
    # Base case if Target found
    if (np.array_equal(src,target)):
      return True
    
    # Base case if limit exceeded
    if (limit <= 0):
      return False
    
    # Add source to visited_states
    visited_states.append(src)
    
    # Find possible slides up, down, left right to current empty site
    ### Jump to possible_moves function
    moves = possible_moves(src, visited_states)

    # For all possible moves gotten from the possible moves function
    # Check if src equals to new targets
    # Return True if target found in given depth limit
    for move in moves:
      if (dfs(move, target, limit-1, visited_states)):
        return True

    return False



import numpy as np

def possible_moves(state,visited_states):
    # Find index of empty spot and assign it to b
    b = np.where(state == -1)  
    row = b[0][0]
    column = b[1][0]

    #'d' for down, 'u' for up, 'r' for right, 'l' for left - directions array
    d = []

    #Add all possible direction into directions array - Hint using if statements
    if (row == 0):
      d.append('d')
    elif (row == 1):
      d.append('d')
      d.append('u')
    elif (row == 2):
      d.append('u')

    if (column == 0):
      d.append('r')
    elif (column == 1):
      d.append('r')
      d.append('l')
    elif (column == 2):
      d.append('l')
    
    # If direction is possible then add state to move
    pos_moves = []
    
    # for all possible directions find the state if that move is played
    ### Jump to gen function to generate all possible moves in the given directions
    for m in d:
      pos_moves.append(gen(state, m, b))

    # return all possible moves only if the move not in visited_states
    for visited in visited_states:
      for possible in pos_moves:
        if (np.array_equal(src,target)):
          pos_moves.remove(possible)

    return pos_moves

import numpy as np

def gen(state, m, b): # m(move) is direction to slide, b(blank) is index of empty spot
    # create a copy of current state to test the move
    temp = state.copy()
    row = b[0][0]
    column = b[1][0]
    element = temp[row][column]
    
    # if move is to slide empty spot to the left and so on
    if (m == 'd' or m == 'u'):
      if (m == 'd'): 
        temp_row = row + 1
      else: 
        temp_row = row - 1

      temp_element = temp[temp_row][column]
      
      temp[temp_row][column] = element
      temp[row][column] = temp_element
    elif (m == 'r' or m == 'l'):
      if (m == 'r'):
        temp_column = column + 1
      else:
        temp_column = column - 1

      temp_element = temp[row][temp_column]
      
      temp[row][temp_column] = element
      temp[row][column] = temp_element
    
    # return new state with tested move to later check if "src == target"
    return temp

"""In the next function:

    

*   Start with a depth of 1 until given depth see if target is reached To find the least depth required to find target 
*   Create a visited_stated array to keep a check
*    Call DFS function for given depth limit


"""

import numpy as np

def ids(src,target,depth):
    #iterative-deepening search
    # Return Min depth at which the target was found
    
    for x in range(9):
      visited_states = []
      temp_depth = depth + x

      if (dfs(src,target,temp_depth,visited_states) == True):
        return temp_depth

    return False



"""In order to simply coding, we may use a list instead of NxN matrix. 

*   Liste öğesi

> Girintili blok


*   Liste öğesi

Alternatively you may utilize pandas or numpy here. Thus, 3x3 matrix will be a 1x9 list.

"""

#Test 1
import numpy as np


src = [1,2,3,-1,4,5,6,7,8]
target = [1,2,3,4,5,-1,6,7,8]

src = np.array(src) 
src = src.reshape(3, 3)

target = np.array(target) 
target = target.reshape(3, 3)

depth = 1
ids(src, target, depth) # Minimum depth should be 2



# Test 2
import numpy as np

src = [1,2,3,-1,4,5,6,7,8] 
target=[1,2,3,6,4,5,-1,7,8]

src = np.array(src) 
src = src.reshape(3, 3)

target = np.array(target) 
target = target.reshape(3, 3)

depth = 1
ids(src, target, depth) # Minimum depth is 1